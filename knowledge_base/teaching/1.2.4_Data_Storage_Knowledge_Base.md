# Unit 1.2.4: Data Storage
## OCR J277 GCSE Computer Science -- Knowledge Base File

---

## Specification Requirements

### 1. Numbers

**Students must know:**
- How to convert positive **denary** whole numbers (0-255) to **binary** numbers (up to and including 8 bits) and vice versa
- How to add two **binary integers** together (up to and including 8 bits) and show working with **carries**
- How to explain **overflow errors** which may occur during binary addition
- How to convert positive denary whole numbers (0-255) into **2-digit hexadecimal** numbers (00-FF) and vice versa
- How to convert binary integers to their hexadecimal equivalents and vice versa
- How to perform **binary shifts** (both left and right) and understand their effect on numbers
- Understanding of the terms **'most significant bit'** and **'least significant bit'**

**Key distinction:** 
- **Most significant bit (MSB)**: The left-most bit, representing the highest place value (128 in 8-bit binary)
- **Least significant bit (LSB)**: The right-most bit, representing the lowest place value (1 in 8-bit binary)
- **Binary shift left**: Multiplies the number by 2 for each place shifted
- **Binary shift right**: Divides the number by 2 for each place shifted (integer division)

**Marking language:**
- Accept: Working shown with carries for binary addition (may be above, below, or to the side)
- Accept: 8-bit binary numbers with leading zeros (e.g. 00011010)
- Accept: Hexadecimal in either upper or lower case (e.g. 2F or 2f)
- Do not accept: Binary addition by converting to denary, adding, then converting back (answer mark only, no working mark)
- Do not accept: Binary numbers without leading zeros when 8-bit format specified (e.g. 11010 instead of 00011010)
- Do not accept: Hexadecimal answers missing leading zero (e.g. B instead of 0B)

**Not required:** 
- Conversion of denary to hexadecimal directly (students may convert denary to binary, then binary to hexadecimal)
- Memorisation of hexadecimal values beyond 00-FF range
- Binary numbers beyond 8 bits for GCSE level

### 2. Characters

**Students must know:**
- How **binary codes** are used to represent characters
- The term **'character set'** - a collection of all characters that a computer can represent
- The relationship between the number of bits per character and the number of characters which can be represented
- How **ASCII** represents characters using **8 bits** (or 7-bit with extended-ASCII distinction avoided at GCSE)
- How **Unicode** represents characters using **16 bits** (allowing representation of more characters)
- That character sets store **unique** binary codes for each character
- That upper-case and lower-case letters are given **different** binary codes
- That character codes in a character set are **sequential** (e.g. if 'A' is 65, then 'B' is 66)

**Key distinction:**
- **ASCII**: 8-bit character set, can represent 256 different characters, suitable for English language
- **Unicode**: 16-bit character set, can represent 65,536 different characters, supports multiple languages and symbols including emojis

**Marking language:**
- Accept: "Character set stores all of the characters" or "all the different characters"
- Accept: "Each character is given a unique binary code" or "different binary code"
- Accept: "7-bit ASCII" or "8-bit ASCII" depending on context
- Accept: "varchar" and "single/double" as synonyms for string and real/float (from DBMS software)
- Do not accept: "Character set stores some of the characters"
- Do not accept: "Each character is given an identical code" or "repeated code"
- Do not accept: Generic "variable" or "input" when asked for data type

**Not required:**
- Memorisation of specific ASCII or Unicode values
- Distinction between ASCII and extended-ASCII at GCSE level
- Understanding of UTF-8, UTF-16 or other Unicode encodings

### 3. Images

**Students must know:**
- How an image is represented as a series of **pixels**, each represented in binary
- The term **metadata** - additional information stored with an image file
- The effect of **colour depth** on image quality and file size
- The effect of **resolution** on image quality and file size
- That each pixel has a specific colour represented by a binary value
- Common metadata stored with images (e.g. width, height, colour depth, date taken, camera settings)

**Key distinction:**
- **Colour depth**: Number of bits used to represent each pixel's colour (e.g. 4-bit = 16 colours)
- **Resolution**: Dimensions of the image in pixels (width x height)
- Increasing colour depth or resolution increases both quality AND file size

**Marking language:**
- Accept: "Metadata stores additional image information"
- Accept: Examples of metadata: "width", "height", "colour depth", "file size", "date taken", "camera model", "location"
- Do not accept: "The image itself" or "the pixel data" as metadata

**Not required:**
- Specific image file formats (JPEG, PNG, etc.)
- Compression techniques for images (covered in 1.2.5)
- Calculation of image file sizes using the formula (covered in 1.2.3 Units)

### 4. Sound

**Students must know:**
- How **analogue sounds** can be sampled and stored in digital form
- The term **sample rate** - measured in Hertz (Hz), number of samples taken per second
- The term **duration** - how many seconds of audio are recorded
- The term **bit depth** - number of bits available to store each sample (e.g. 16-bit)
- The effect of sample rate on playback quality and file size
- The effect of duration on file size
- The effect of bit depth on playback quality and file size

**Key distinction:**
- **Higher sample rate** = better quality, larger file size
- **Higher bit depth** = better quality (more accurate representation of amplitude), larger file size
- **Longer duration** = larger file size only (no quality change)

**Marking language:**
- Accept: "Sample rate is measured in Hertz" or "Hz"
- Accept: "Bit depth is the number of bits per sample"
- Accept: "Duration is the length of the sound in seconds"

**Not required:**
- Understanding of analogue-to-digital conversion circuits
- Specific sound file formats (MP3, WAV, etc.)
- Nyquist theorem or advanced sampling theory
- Calculation of sound file sizes using the formula (covered in 1.2.3 Units)

---

## Examiner Intelligence

### Recurring Misconceptions (flagged in examiner reports 2022-2025)

1. **"I can convert binary to denary by adding, then convert back to binary for addition"**
   - This method gives the correct answer but does NOT show working for binary addition
   - Students lose the working mark (only gain answer mark)
   - Source: June 2022, June 2023, June 2024, June 2025 J277/01 examiner reports

2. **"The smallest number in 8-bit binary is 1"**
   - The smallest whole number that can be represented in 8 bits is 0 (00000000)
   - Many candidates gave 1 instead of 0
   - Source: June 2022 J277/01 examiner report Q1(a)

3. **"When converting to 8-bit binary, I don't need leading zeros"**
   - 8-bit binary MUST have exactly 8 bits, including leading zeros
   - Example: 11010 must be written as 00011010 when 8-bit format specified
   - Source: June 2022, June 2023 J277/01 examiner reports

4. **"Hexadecimal B is the same as 0B"**
   - When converting binary to hexadecimal, both digits must be shown
   - 0B and B represent different values (11 vs 176)
   - Missing the leading zero alters the value produced
   - Source: June 2022 J277/01 examiner report Q1(d)

5. **"F in hexadecimal is 1101 in binary"**
   - F in hexadecimal is 15 in denary, which is 1111 in binary (not 1101)
   - 1101 would be 13 in denary (D in hexadecimal)
   - This error leads to incorrect conversions in multi-step questions
   - Source: June 2022 J277/01 examiner report Q1(c)

6. **"4 bits can represent 15 unique values"**
   - 4 bits can represent 16 unique values (0-15), not 15
   - Many candidates calculate 2^4 = 16 but forget to include 0
   - Source: June 2022 J277/01 examiner report Q1(e)

7. **"Each character in a character set has an identical code"**
   - Each character must have a UNIQUE binary code
   - "Identical" or "repeated" codes would make characters indistinguishable
   - Source: June 2023 J277/01 examiner report Q3(a)

8. **"ASCII uses 256 bits for each character"**
   - ASCII uses 8 bits per character (not 256 bits)
   - 8 bits allows for 256 different characters
   - Candidates confused bits per character with total possible characters
   - Source: June 2023 J277/01 examiner report Q3(a)

9. **"Unicode has fewer bits than ASCII"**
   - Unicode uses MORE bits than ASCII (16-bit vs 8-bit)
   - This is why Unicode can represent more characters
   - Some candidates incorrectly reversed this relationship
   - Source: June 2025 J277/01 examiner report Q6(b)

10. **"When adding binary numbers, I don't need to show carries"**
    - Showing carries is REQUIRED to gain the working mark
    - Carries can be shown above, below, or to the side
    - Only writing the final answer gives answer mark only
    - Source: June 2023, June 2024, June 2025 J277/01 examiner reports

11. **"A left shift means multiplying by 4 or 8 positions"**
    - Direction (left/right) AND number of places must both be specified
    - Candidates often gave only the direction without the number
    - Both elements required for full marks (2 marks available)
    - Source: June 2023, June 2025 J277/01 examiner reports

### Common Mark Losses

- **Not showing working** for binary addition (converting to denary and back loses working mark)
- **Missing leading zeros** in 8-bit binary numbers
- **Incorrect F to binary conversion** (giving 1101 instead of 1111)
- **Missing leading zero in hexadecimal** (writing B instead of 0B)
- **Forgetting zero** when calculating range of values representable
- **Overwriting answers** (writing 0 over 1 or vice versa) making intended answer unclear
- **Not using 8-bits** terminology correctly (saying "8-bits" when specification requires precision)
- **Incomplete binary shift descriptions** (giving direction without number of places)
- **Incomplete carries shown** (e.g. showing 2 carries when 3 are needed, or not showing final carry)

### Question Patterns (2022-2025)

- **Multi-base conversion tables**: Appear every year, typically 4 marks, requiring denary/binary/hexadecimal conversions
- **Binary addition with carries**: Appears every year, 2 marks (1 for working, 1 for answer)
- **Hexadecimal to denary conversion with method**: Appears 2022, 2024 (3 marks - example + method description)
- **Binary shift identification**: Appears 2022, 2023, 2025 (2 marks - direction + places)
- **Binary shift application**: Appears 2024, 2025 (1 mark - identifying result)
- **Character set completion**: Appears 2023 (5 marks - gap-fill style)
- **Data type selection**: Appears 2025 (2 marks)
- **Range questions**: Appears 2022, 2024 (asking for smallest/largest values, unique values representable)
- **No gaps** in coverage - numbers, characters, images, and sound have all been examined
- **Dominant mark allocation**: 1-4 marks per question, with occasional 3-mark "describe" questions
- **Consistent weighting**: Data storage typically accounts for 8-15 marks on J277/01 (out of 80 marks total)

---

## Quick Reference

### Number Conversions

**Denary range:** 0 - 255  
**Binary range:** 00000000 - 11111111  
**Hexadecimal range:** 00 - FF

**Binary to Denary:**
- Each bit position represents a power of 2 from right to left: 128, 64, 32, 16, 8, 4, 2, 1
- Add together the values of all bits that are 1

**Denary to Binary:**
- Use repeated division by 2, recording remainders
- OR use place value method (subtract largest possible power of 2 repeatedly)
- Always pad to 8 bits with leading zeros

**Hexadecimal to Denary:**
- Method 1: Convert each hex digit to 4-bit binary, combine, convert to denary
- Method 2: Multiply left digit by 16, add right digit value

**Binary to Hexadecimal:**
- Split 8-bit binary into two 4-bit nibbles
- Convert each nibble to hex digit (0-F)
- Remember both digits must be shown (e.g. 0B not B)

### Binary Addition Rules

- 0 + 0 = 0
- 0 + 1 = 1
- 1 + 0 = 1
- 1 + 1 = 10 (write 0, carry 1)
- 1 + 1 + 1 = 11 (write 1, carry 1)

**Always show carries** to gain working marks.

### Binary Shifts

**Left shift by n places:** Multiplies by 2^n  
- Left shift 1 place = multiply by 2
- Left shift 2 places = multiply by 4
- Left shift 3 places = multiply by 8

**Right shift by n places:** Divides by 2^n (integer division)
- Right shift 1 place = divide by 2
- Right shift 2 places = divide by 4

**Specification requires:** Direction (left/right) AND number of places for full marks.

### Character Sets Quick Facts

| Character Set | Bits per character | Total characters | Languages |
|--------------|-------------------|------------------|-----------|
| ASCII | 8 bits | 256 | English |
| Unicode | 16 bits | 65,536 | Multiple, including emojis |

**Benefit of Unicode:** More characters, multiple languages, emojis  
**Drawback of Unicode:** Larger file size, double the storage of ASCII

### Key Exam Language

**Say this:**
- "Show carries when adding binary numbers"
- "8-bit binary must include leading zeros"
- "Character set stores all/unique characters"
- "Each character has a different/unique binary code"
- "Unicode uses more bits than ASCII"
- "Left shift 3 places" (not just "left shift")

**Not that:**
- "Add in denary then convert back" (loses working mark)
- "Binary can be any length" (must be 8-bit when specified)
- "Characters have identical codes" (must be unique)
- "Unicode is smaller than ASCII" (reversed)
- "Shift left" without number of places (incomplete)
